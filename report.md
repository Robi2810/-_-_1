# Архитектура вычислительных систем
## Индивидуальное домашнее задание №1
### Вариант 14


##### Вишняков Родион Сергеевич 
##### группа БПИ213
###### 16 октября 2022 г.



Задание: Сформировать массив B из элементов массива A заменой всех отрицательных значений на максимум из массива A.
Отчёт
![img](/p1.png)

### 4 балла
•	Приведено решение задачи на C.

Код находится в файле main.c
Далее в командную строку вводим данные команды для получения искомого ассемблерского файла, а также исполняемого файла.


$gcc -O0 -Wall -fno-asynchronous-unwind-tables main.c -o main


$gcc -O0 -Wall -fno-asynchronous-unwind-tables -S main.c -o main.s


$gcc main.s -o


Необходимые комментарии находятся в main.s


Файл | Тест           | Результат | Соотвествие 
-----------|----------------|:---------:|------------:
main.c     | 1 -1 -1 1 1    | 1 1 1 1 1 |        True | 
main.s     | 1 -1 -1 1 1    | 1 1 1 1 1 |        True |
main.c     | 3 -3 4 -5 6	   | 3 6 4 6 6 |       True      |
main.s     | 3 -3 4 -5 6    | 3 6 4 6 6 |       True      |
main.c     | 1 -2 -3 -4 9	  | 1 9 9 9 9 |      True       |
main.s     | 1 -2 -3 -4 9	  | 1 9 9 9 9 |     True        |
main.c     | 1 -1 -1 -1 -1	 | 1 1 1 1 1 |      True       |
main.s     | 1 -1 -1 -1 -1	  | 1 1 1 1 1 |     True        |


Представлено полное тестовое покрытие, дающее одинаковый результат на обоих программах.
После тестирования программ можно сделать вывод, что работа программы является корректной и эквивалентной.

### 5	баллов
В дополнение к требованиям на предыдущую оценку

•	В реализованной программе я использовал функции с передачей данных через параметры.
![img](/p2.png)

Измененная программа была сохранена в файле main2.c

Функциональность:


input_max() - получает на вход размер массива N и указатель на массив в которые будут заполняться данные. При выполнении этой функции мы получаем массив и функция возвращает максимальное число среди элементов массива.


out_put() - получает на вход размер массива N и указатель на массив, который необходимо напечатать.


task() - получает на вход указатель на начальный массив и массив, в который будет записываться результат, количество элементов в массиве и максимальный элемент из изначального массива.


Комментарии:
В ассемблерскую программу при вызову функций были добавлены комментарии, которые описывают передачу фактических параметров и перенос возвращаемого результат, в случае когда функция ничего не возвращает был добавлен комментарий (void )
В этой программе не использовались формальные параметры.

### 6 баллов
В дополнение к требованиям на предыдущую оценку
Я сделал рефакторинг программы на ассемблере за счет максимального использования регистров процессора. Измененная программа сохранена в файле “main2-refactored.s”. В основном были использованы регистры: r12, r13, r14, r15. В процессе рефакторинга соотвественно были изменены команды (например movl -> movq), а также были изменены регистры, которые контактировали с “новыми” регистрами (например: movl eax, -24(%rbp) -> movq rax, r12).
Также были добавлены комментарии, которые поясняют использование регистров в соответсвии с переменными из исходной программы на С.

Файл | Тест           | Результат | Соотвествие
-----------|----------------|:---------:|------------:
main2.c     | 1 -1 -1 1 1    | 1 1 1 1 1 |        True | 
main2.s     | 1 -1 -1 1 1    | 1 1 1 1 1 |        True |
main2-refactored.s     | 1 -1 -1 1 1	   | 1 1 1 1 1 |       True      |
main2.c     | 3 -3 4 -5 6    | 3 6 4 6 6 |       True      |
main.s     | 3 -3 4 -5 6	   | 3 6 4 6 6 |      True       |
main2-refactored.s       | 3 -3 4 -5 6	   | 3 6 4 6 6 |     True        |
main.c     | 1 -2 -3 -4 9	  | 1 9 9 9 9 |      True       |
main.s     | 1 -2 -3 -4 9	  | 1 9 9 9 9 |     True        |
main2-refactored.s     | 1 -2 -3 -4 9	  | 1 9 9 9 9 |     True        |

Представлено полное тестовое покрытие, дающее одинаковый результат на всех программах.

### 7 баллов
В дополнение к требованиям на предыдущую оценку

Реализация программы на ассемблере, полученной после рефакторинга, в виде двух единиц компиляции (2-1.s & 2-2.s).
Я разделил код ассемблера на файл с функциями и файл с main. Далее скомпилировал полученные файлы и запустил файлы с исходными данными и файла для вывода результатов с использованием аргументов командной строки.
![img](/p3.png)
Далее я переделал файл Си, чтобы он брал и записывал данные из вводимых в командную строку файлов. (int argc, char * argv[]) измененная программа была сохранена под названием “main3.c”
После чего эта программа была скопилирована в main3.s и разделена на файлы 3-1.s и 3-2.s, в которых были функции и main соответсвенно.
![img](/p4.png)

### 8 баллов
В дополнение к требованиям на предыдущую оценку

•	Добавление в программу генератора случайных наборов данных, расширяющих возможности тестирования. Подключение генератора к программе с выбором в командной строке варианта ввода данных.
•	Расширение анализа командной строки для выбора способа порождения исходных данных. Добавление данных, порождаемых генератором.
•	Модификация программы на C и программы на ассемблере, полученной после рефакторинга, для проведения сравнения на производительность. Необходимо добавить замеры во времени, которые не учитывают время ввода и вывода данных. Для увеличения времени работы минимум до 1 секунды, в зависимости от особенностей программы, можно либо выбирать соответствующие размеры исходных данных, либо зацикливать для многократного выполнения ту часть программы, которая выполняет вычисления.
•	Представить полученные данные в отчете для разных вариантов тестовых прогонов
При невыполнении хотя бы одного из требований оценка снижается на балл.

### 9 баллов
В дополнение к требованиям на предыдущую оценку

•	Используя опции оптимизации по скорости, сформировать из модифицированной программы на C исходный код ассемблере. Провести сравнительный анализ с предыдущими ассемблерными программами по размеру ассемблерного кода, размеру исполняемого файла и производительности.
•	Аналогично, используя опции оптимизации по размеру, сформировать код на ассемблере. Провести сравнительный анализ с предыдущими ассемблерными программами по размеру ассемблерного кода, размеру исполняемого файла и производительности.
•	Представить в отчете полученные результаты, дополнив данные представленные в предыдущем отчете.
При невыполнении хотя бы одного из требований оценка снижается на балл.

### 10 баллов
В дополнение к требованиям на предыдущую оценку

•	Использование вместо libc библиотеки, опирающейся на системные вызовы операционной системы, разработанной самостоятельно или адаптированной из найденных информационных источников. По сути в данном случае вместо компиляции и рефакторинга программы на C, будет получена программа, написанная «вручную».
•	Провести тестовые прогоны данной программы. Оценить производительность.
•	Расширить отчет, дополнив его новыми данными.
При невыполнении хотя бы одного из требований оценка снижается на балл.
